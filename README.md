# Coding-Ninjas-Competitive-Programming
This Repository Contains all my codes which I wrote during the competitive programming course with <a href="https://www.codingninjas.com/">Coding Ninjas</a></br></br>

# Insights (In Hinglish)
:slightly_smiling_face: Merge sort is better than selection sort</br>
:slightly_smiling_face: In bubble sort we compare the first two elements then the next two elements.. and so on, multiple times. So the time complexity of bubble sort is O(n^2).</br>
:slightly_smiling_face: time complexity of insertion sort is O(n^2) because it inserts the elements of the array into the sorted part of the array iteratively.</br>
:slightly_smiling_face: Selection sort is also of the order of n^2 because the smallest element is selected from.the unsorted array and swapped with the leftmost element and that element becomes the part of the sorted array.</br>
:slightly_smiling_face: For binary search, the time complexity is O(log(n)), because .---->watch theoretical analysis - recursive algorithm in time and space complexity analysis lecture.</br>
:slightly_smiling_face: Time complexity of merge sort is O(n*log(n)). Because here we divide our array into.two parts and sort them separately and then merge them.</br>
:slightly_smiling_face: Time and space complexity analysis is very important lecture. kadane's algorithm video lecture is very important too. it has been asked in many popular companies.</br>
:slightly_smiling_face:set is implemented in c++ using a balanced binary search tree. it takes log(n) time to find an element in a set or in binary search tree.</br>
:slightly_smiling_face:map also uses a binary search tree in the backend. it also takes log(n) time for insertion, deletion, and finding as well, in this way it is different from an unordered map. unordered map is implemented using hashtable. In an unordered map, finding, inserting, and deletion takes O(1) time in average case and O(n) in worst case. worst case bohot kam aata hai. mostly average case hi use hota hai, to in general time complexity for an unordered map is considered to be of the order of 1.</br>
:slightly_smiling_face:jab indexes and elements ko compare karne ka man kare aur aisa lag raha ho ki tumhara solution order of n square time lega then merge sort k baare mei sochna.</br>
:slightly_smiling_face: for flipping the ith bit we use xor operator (^). (edited)</br> 

# Important lectures and questions to revised again(bookmarks):
1. Oscillating prices of chakri in prerequisites lecture
2. Arrays and pointers video lecture in lecture: pointers(optional to understand c++)
3. "what is the output" question after arrays and pointers video lecture in lecture: pointers(optional to understand c++)
4. characters and pointers video lecture in Lecture : Pointers(Optional To Understand C++)
5. Address type casting in lecture :dynamic allocation(optional to understand c++)
6. reference and pass by reference video lecture in Lecture : Dynamic Allocation(Optional To Understand C++)
7. second and third fill the output question after macros global variable video lecture in Lecture : Dynamic Allocation(Optional To Understand C++).
8. First index of a number in lecture: basics of recursion
9. Last index of a number in lecture :basics of recursion. Although i did it in the firat attempt, but i liked this one.
10. all indices of number in lecture: basics of recursion.
11. time and space complexity analysis lecture is very important.
12. live question 1 in time and space complexity lecture.
13. live question 2 in the lecture time and space complexity analysis.
14. live question 3 in lecture language tools. i can;t do it.
15. warm reception in language tools.. it is a very good question. clears all the concepts of time complexity.
16. triplet sum in language tools + time complexity assignment.
17. longest consecutive sequence in lecture language tools + time and complexity assignment
18. aggressive cows problem in searching and sorting applications. - i did it myself and is a very good problem.
19. aggressive cows and inversion count problems are searching ans sorting applications respectively. these are very important.
20. searching and sorting applications lecture is very very important.
21. last question of advanced recursion.
22. alpha code question in dynamic programming-1.
23. largest bitonic subarray in dynamic programming -1 lecture. (I raised a doubt regarding this. I couldn't do it myself).
24. dynamic programming-1 live question 1.
25. dynamic programming-1 live question 2
26. dynamic programming -1 -minimum count question.
27. adjacent bit count and the problem before that are important. these are for the basic concept. in dynamic programming-1.
28. All the assignment questions in DP-1 are important af.
29. last problem of DP-1 is also very important, I couldn't do it myself
30. balika vadhu probelm in dp-2.
31. Trader Profit in dp2.
32. Distinct subsequences in dynamic programming 2.
33. shortest subsequence in dp2.
34. weighted job scheduling in greedy problems(very very important)
35. 2vs3 in segment trees
36. Prims algorithm in graphs 2
37. connected horses in advanced graphhs.
38. FillMTR in Advanced Graphs.

# Lectures to be done again
1. Greedy
2. Advanced Graphs
